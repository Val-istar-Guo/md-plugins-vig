# Snapshot report for `test/articles.js`

The actual snapshot is saved in `articles.js.snap`.

Generated by [AVA](https://ava.li).

## # articles

> Snapshot 1

    `<h1>Vue-Koa 同构开发环境</h1><p>虽然 Vue 已经提供了近乎完美的工程化工具 vue-cli，但是对于一些人来说，自行搭建一个灵活的开发环境也是一个不错的选择。这篇文章将介绍我是如何使用Vue、Koa、PM2等常用框架搭建一个更适合我个人开发的工程环境。␊
    ␊
    </p><p>读这篇文章前，你必须要了解的内容有: Vue, Koa, Webpack, Babel␊
    ␊
    </p><p>可以下载<a href="https://github.com/Val-istar-Guo/vue-boilerplate">Github仓库</a>以供阅读文章参考或提出修改建议。␊
    ␊
    ␊
    ␊
    </p><h2>功能需求</h2><ul><li class="ul">开发环境的 Hot Reload （热重载）是必不可少的</li><li class="ul">支持 Server Side Render （服务器渲染）</li><li class="ul">兼容非同构 nodeJS 模块的使用</li><li class="ul">通过 PM2 快速部署项目</li></ul><h2>Hot Reload</h2><p>Webpack 提供 Hot Reload 支持，Vue本身也支持 Hot Reload。因此，仅需在 webpack 配置文件中进行如下配置：␊
    ␊
    </p><pre><code class="javascript">{␊
      // More Config...␊
      bundle: [␊
        &#39;Your Entry File&#39;,␊
        &#39;webpack-hot-middleware/client&#39;,␊
      ],␊
      // More Config...␊
    }</code></pre><h2>Server Side Render</h2><h3>实现</h3><p>Vue 具有极好的生态环境，我们可以直接使用<code>vue-server-renderer</code>。这里我们使用的是<code>vue-server-renderer</code> 提供的 <code>createBundleRenderer()</code> 方法通过<code>vue-ssr-bundle.json</code>文件进行渲染。␊
    ␊
    </p><p><code>vue-ssr-bundle.json</code> 文件是通过<code>vue-ssr-webpack-plugin</code>生成的 Client 端代码（具体编译成的内容意义我也不清楚）。这样我们就不需要在 Server 端引入 Client 端代码，再去渲染。仅仅需要将 <code>vue-ssr-webpack-plugin</code> 生成的<code>vue-ssr-bundle.json</code>文件内容作为参数传入 <code>createBundleRenderer()</code> 方法，就可以得到 Client 端 HTML 的渲染结果。␊
    ␊
    </p><p>更具体的说明请移步<a href="https://ssr.vuejs.org/zh/">Vue Server Side Render文档</a>。文档中对通过Vue实现服务端渲染有详细对说明。本项目参照其基本结构搭建客户端部分代码，如果你初次接触这部分，可能对<code>entry-ssr.js</code>、<code>entry-client.js</code>、<code>createRouter.js</code>等文件的结构和写法疑惑不解，甚至怀疑这些文件存在的必要性，不过在<a href="https://ssr.vuejs.org/zh/">Vue Server Side Render文档</a>中都对其进行了详细解释。␊
    ␊
    ␊
    ␊
    </p><h2>兼容非同构模块使用</h2><p>虽然 <code>vue-server-renderer</code> 虽然使用方法非常便捷而神奇，但是依旧不能自动的支持非同构的 JS 代码在Server端运行。例如，如果你使用<code>Chart.js^2.5.0</code>（一个小巧的图标绘制插件），将会报错<code>Cannot Find xxx from undefined</code>。这里是由于未定义的变量<code>window</code>导致的。我们都知道，<code>window</code>是浏览器中的变量而NodeJS环境中并不存在。在服务端运行这样的代码是不可能的，但放着如此不错的插件不用，未免太可惜了。␊
    ␊
    </p><p>我们可以通过一个折衷的方法，通过在生成ssr所使用的webpack配置文件中设定别名，将模块指向一个代替模块。默认代替模块为<code>empty.js</code>，webpack 配置如下：␊
    ␊
    </p><pre><code class="javascript">// empty.js␊
    export default null;</code></pre><pre><code class="javascript">// webpack.config.ssr.js␊
    {␊
      // More Config...␊
      resolve: {␊
        // More Config...␊
        alias: {␊
          chart: path.resolve(__dirname, &#39;empty&#39;),␊
        },␊
      },␊
      // More Config...␊
    }</code></pre><pre><code class="javascript">// webpack.config.client.js &amp; webpack.config.client.dev.js␊
    {␊
      // More Config...␊
      resolve: {␊
        // More Config...␊
        alias: {␊
          chart: &#39;chart.js&#39;,␊
        },␊
      },␊
      // More Config...␊
    }</code></pre><p>这里必须注意，别名不能与node中安装的模块重名。因此这里使用<code>chart</code>作为别名而不是<code>chart.js</code>。在使用的时候要注意，在服务端渲染时chart.js会被empty.js代替。␊
    ␊
    </p><pre><code class="javascript">import Chart from &#39;chart&#39;;␊
    ␊
    if (Chart !== null) {␊
      // running on client;␊
    } else {␊
      // running on server side render;␊
    }</code></pre><p>虽然这样处理并不优雅，至少能解决燃眉之急。最佳的方案还是选择一些同构的模块，这仅仅作为一个应急方案。␊
    ␊
    ␊
    </p><p>由于webpack有许多需要根据项目灵活控制的部分。为了方便管理，我们将这部分统一放置在<code>webpack.config.expand.js</code>文件中。server/client/ssr等部分的webpack配置均从此文件中导入响应配置。␊
    ␊
    </p><pre><code class="javascript">import path from &#39;path&#39;;␊
    ␊
    ␊
    // 扩展配置␊
    export default {␊
      ssrFileName: &#39;vue-ssr-bundle.json&#39;,␊
      manifestFileName: &#39;vue-ssr-manifest.json&#39;,␊
      /**␊
       * 非同构模块, 不可用于ssr在server端运行␊
       * 会被默认替代为empty.js␊
       * 需要在代码中进行兼容处理␊
       */␊
      nonIsomorphicModule: {␊
        // chart: &#39;chart.js&#39;,␊
      },␊
    ␊
      // 非JS模块，不可用于ssr, ssr代码需要在nodejs中运行␊
      nonJsModule: [␊
        &#39;normalize.css&#39;,␊
      ],␊
    ␊
      // 外部依赖库，打包成独立js包␊
      lib: [␊
        &#39;vue&#39;,␊
        &#39;vuex&#39;,␊
        &#39;vue-router&#39;,␊
        &#39;detect-env&#39;,␊
        &#39;superagent&#39;,␊
      ],␊
    ␊
      alias: {␊
        framework: path.resolve(__dirname, &#39;../framework&#39;),␊
      },␊
    }</code></pre><h2>快速部署</h2><p>PM2提供来快速部署的方法，如果你想详细了解如何使用，最好学习PM2然后了解 ecosystem.config.js 中的PM2配置。␊
    ␊
    ␊
    ␊
    </p><h2>开发体验</h2><h3>Node Server Reload</h3><p>这里并没有使用nodemon来做node server重启，而是直接使用PM2来做，目的是减少一些不必要的包依赖。配合 Hot Reload 可以达到一流的开发体验。␊
    ␊
    </p><h3>格式约束</h3><p>使用<code>.editorconfig</code>编辑器基本格式。对于代码风格，本来作者打算使用 eslint + airbnb进行，但是vue文件又不太适合。在 Server 端也存在大量的JS文件，真希望有个完美的eslint插件。␊
    ␊
    </p><h3>默认别名</h3><p>在这个模版中，<code>framework</code>分别用于存放在 Server 端和 Client 端都会使用的公共静态变量和工具模块。为了方便使用，在两端都设置了别名(framework)。␊
    ␊
    </p><p>由于引入了webpack的别名机制，server端代码必须经过webpack编译后运行。在这里，<code>build/server.dev.js</code>帮我们进行了server端代码端编译和运行。因此<code>webpack.config.expand.js</code>中配置对别名对于server端也是生效的。␊
    ␊
    ␊
    ␊
    </p><h2>Problems</h2><h3>PM2 无法与 Git 1.8 协同工作</h3><p>和我一样使用CentOS的也大有人在，但是CentOS默认Yum仓库的git版本还停留在古老的 1.8 版。当你的服务器git版本为 1.8.x时，使用PM2部署到该服务器，将无法获取仓库中提交的最新版本，我并不知道这是为什么，最简单的解决方案就是更新CentOS的git到最新版。␊
    ␊
    </p><h3>yarn or npm 安装依赖时被随机kill</h3><p>使用PM2部署时会首先安装需要的依赖，在使用<code>yarn</code>或<code>npm i</code>时，可能会提示被kill掉，导致部署失败。这很可能时由于你租用的服务器内存太小的缘故（本项目的依赖稍多）。作者使用的是 1核1G的 的CentOS，通过添加一个 1G 的swap 可以解决这个问题。␊
    ␊
    </p><h3>nonJsModule 配置问题</h3><p>在 webpack.config.expand.js 中存在一个字段为<code>nonJsModule</code>。它含义是在server端无法直接运行，但是在client端需要的文件，最明显的例子就是css文件。由于服务端渲染端缘故，client端代码将专名打包并在服务端运行。默认情况下，为了使ssr部分端client端打包文件尽可能小，会自动的移除package.json中指明的依赖。␊
    ␊
    </p><p>我们不难想到，之所以可以在client端直接import css文件是因为有webpack端loader做处理。如果ssr部分移除了package.json指明的依赖，这些依赖也将不会被loader处理，而原生的nodejs并不能直接解析／读取CSS文件。因此，如果在package.json指明的依赖不是可以在node环境中直接运行的文件，则这些文件需要被webpack处理并一起打包到ssr端的运行文件中去。</p>`

> Snapshot 2

    `<h1>为脏数据消毒</h1><h6>不应该在组件渲染代码中为数据的正确性进行复杂判断，既：注入组件的数据必须为正确的。</h6><p>对于稍大一些的项目，往往是多人合作开发。在前端和后端交互过程中，数据是否与预期相同是极为重要的。因为前端需要将数据展示到界面上供用户观看，例如我们获取了一个商品列表，我们会循环将列表的内容渲染为界面元素，但是如果商品列表为空时，接口返回的是null而不是空列表，我们的渲染代码就会直接挂掉。这时候前端就不得不多一个判断。但是当数据嵌套多层，有许多数据都需要判断的时候，前端就成了一坨shit。␊
    ␊
    </p><p>那我们有必要要求服务提供者保证数据结构的正确性么？答案肯定是否定的。因为服务的提供者提供的某个数据字段只是依赖其他服务提供者，填充大量的默认字段对他们来说看上去像是一坨shit。更重要的是，服务的提供者代码也可能有bug导致字段数据出错。前端不能因为后端bug导致自身服务崩溃。␊
    ␊
    </p><p>因此，在获得接口数据后，<strong class="asterisk">对数据进行消毒后使用能够很好提高服务稳定性<strong class="asterisk">，同时我们可以</strong>提高组件渲染代码的可维护性</strong>␊
    ␊
    </p><p>简单的来说，我们可以在获取数据后对数据字段进行判断并附上默认值，然后再交给渲染逻辑部分进行渲染。但是如果我们数据中存在多层数据，那么我们用来消毒的代码可能写成多重循环，这让代码变得不容易维护。有时候，可能我们的接口为了未来的扩展性而保留一些多余的设计，例如多余的字段。有时候我们又要求数组至少有一个展示给用户的有意义的值，对于没有意义的数据我们要抛弃掉，避免渲染造成用户误操作。如果你真的通过循环判断的方法来写，这部分代码的维护将是及其痛苦的。这也是我开发 Sanitization 的缘由。␊
    ␊
    ␊
    </p><h2>什么样的数据是合理的</h2><h3>完整的数据结构</h3><p>数据结构的完整性是指，当我们获得的是一个空数组的数据时，这个数据应当是<code>[]</code>而不应该是<code>null</code>或<code>undefined</code>。因为如果为<code>null</code>，那么我们渲染代码中<code>arr.map</code>这类的循环代码可能报错，导致界面渲染失败。又比如获得的空对象是<code>null</code>，<code>obj.prop</code>代码也会报错。␊
    ␊
    </p><p><strong class="asterisk">我们不应该在组件的渲染逻辑中判断判断数据是否为空进行不同的渲染</strong>，我们应该将数据中的对象赋予完整的属性默认值和数组至少为空数组以保证渲染逻辑中的取值和循环操作可以正常运行。也保证渲染逻辑部分的代码是干净整洁、易于维护的。␊
    ␊
    </p><h3>有意义的数据</h3><p>对于一条数据，其数据结构的完整并不代表可以将其渲染出来。<strong class="asterisk">如果数据的关键信息异常，我们必须避免将其渲染到界面</strong>，这些异常数据可能导致用户误操作。␊
    ␊
    </p><p>例如，如果我们有一个用户购买商品的商品列表，我们获取了一个商品列表的数组，每一项都包含一条商品信息，如下：␊
    ␊
    </p><pre><code class="javascript">const goods = [␊
    	{␊
    		id: 1,␊
    		name: &#39;洗洁精&#39;,␊
    		price: 10,␊
    	},␊
    	{␊
    		id: 2,␊
    		name: &#39;晾衣架&#39;,␊
    		price: null,␊
    	},␊
    ]</code></pre><p>可能由于后端服务出现异常，晾衣架的<code>price</code>数据并没有返回。我们并不应该将这个数据渲染到界面，避免用户选择购买该商品，最终导致前端计算价格和最终结算展示的价格不一致导致客户投诉。（同时我们或许应该上报这个数据异常）。因此，客户最终看到的可以操作的有效商品只有洗洁精。␊
    ␊
    </p><h3>不同的场景，不同的脏数据</h3><p><strong class="asterisk">同样的一个接口获取的相同的数据信息，面对不同的操作者在不同的业务场景下，我们的处理方式往往是不同的。</strong>为了说明这个问题，我依旧使用上面的例子提到的错误数据。␊
    ␊
    </p><p>首先，我们分析一下<code>price</code>字段为空可能的两个原因：␊
    ␊
    </p><ol><li class="ol">接口代码bug导致price字段为空</li><li class="ol">数据库被存入了脏数据，接口将脏数据返回给了我们</li></ol><p>在上个例子中，我们目的是展示给消费者进行操作。让我们换一个身份，我们现在是这个超市的管理员，我们需要编辑我的商品列表。␊
    ␊
    </p><p>同样是上面的列表，这次渲染编辑页面的时候，不应该将<code>price</code>字段为null的数据过滤掉，而是将这个数据默认设置为一个空字符串。这样做的原因是，当管理员发现数据为空并重新填写保存后，如果是由于数据库被存入脏数据导致的数据为null的情况，数据会被修正并保存到数据库中。这样管理员可以最快速的解决问题，并让消费者看到商品。至于接口提供者，则可以根据日志去寻找脏数据产生原因并解决他们的问题了。␊
    ␊
    ␊
    </p><h2>梦寐以求的工具应该具备什么</h2><ol><li class="ol">声明式语法，声明每一个字段的类型、属性以及限制。</li><li class="ol">配置格式和数据格式高度一致</li><li class="ol">支持过滤非法数据</li><li class="ol">填充默认值，自动进行类型转换</li><li class="ol">语法简洁、精炼</li></ol><h2>Sanitization</h2><p>用一个复杂的例子来说明再好不过了。我们平常去超市，经常遇到换购活动，即：当你购买了100块钱的东西时，可以以优惠的价格10块钱多购买一个卫生纸加一个晾衣架，原价共计20元；或者以20元的价格多购买一个原价50元的拖把。␊
    ␊
    </p><p>作为超市的管理者，你希望卫生纸和晾衣架是打包换购的，不单独换购。你还希望你的操作屏幕上能够让用户看到每个换购商品的图文信息，吸引消费者换购。␊
    ␊
    </p><p>同时，你也是一位大隐于市的牛X前端，你和你的后端同学定了一个还算合理的数据结构：␊
    ␊
    ␊
    </p><pre><code class="javascript">const idealData = {␊
    	// 至少价格要达到100才能参与换购␊
    	minPrice: 100,␊
    	// 活动类型，假设2代表换购␊
    	type: 2,␊
    ␊
    	// 可以换购的物品␊
    	products: [{␊
    		// 物品不能为空，否则消费者看到的可能就是花钱买空气了。␊
    		items: [{␊
    			name: &#39;卫生纸&#39;,␊
    			// 卫生纸原价␊
    			price: 5,␊
    			number: 1,␊
    		}, {␊
    			name: &#39;晾衣架&#39;,␊
    			price: 15,␊
    			number: 1,␊
    		}],␊
    		// 换购价格␊
    		price: 10,␊
    	}, {␊
    		items: [{␊
    			name: &#39;拖把&#39;,␊
    			price: 50,␊
    			number: 1,␊
    		}],␊
    		price: 20,␊
    	}],␊
    }</code></pre><p>没有bug的代码就是什么都不写，后端服务数据如果出现异常，返回如下的信息。␊
    ␊
    ␊
    </p><pre><code class="javascript">const data = {␊
    	minPrice: 100,␊
    	// type 我们获取的就是这个换购活动，因此不需要这个字段␊
    ␊
    	products: [{␊
    		// 没有物品的换购谁花钱啊，这种数据应该过滤掉␊
    		items: null,␊
    		price: 10,␊
    	}，{␊
    		items: [{␊
    			id: 1,␊
    			name: &#39;卫生纸&#39;,␊
    			/**␊
    			 * 卫生纸原价，原价即使不存在也不影响用户实际的消费␊
    			 * 意不意外，惊不惊喜，由于后端bug导致数据输出了个空对象␊
    			 */␊
    			price: {},␊
    			number: 1,␊
    		}, {␊
    			// id是商品的其他接口操作的标符，必须存在␊
    			id: 2,␊
    			name: &#39;晾衣架&#39;,␊
    			price: 5,␊
    			/**␊
    			 * 没有指明数量会导致消费者误操作␊
    			 * 只展示卫生纸也不合理␊
    			 * 因此整个换购项目都需要过滤掉␊
    			 */␊
    			number: null,␊
    		}],␊
    ␊
    		// 这个价格也对消费者来说已非常重要␊
    		price: 10,␊
    	}, {␊
    		items: [{␊
    			name: &#39;拖把&#39;,␊
    			price: 50,␊
    		}],␊
    		price: 20,␊
    	}]␊
    }</code></pre><h3>展示给用户</h3><p>分析一下我们的数据可以看出来，消费之能够安全操作的换购项目只有拖把那一项。␊
    其他项目都会引起消费者误解，导致误操作，引起客户投诉，影响名声。␊
    ␊
    </p><p>因此，为了安全起见，我们需要过滤掉这些内容，先看看如果我们使用传统的方式应该如何编码。␊
    ␊
    ␊
    </p><pre><code class="javascript">const safeData = {␊
    	...data,␊
    ␊
    	products: !data.products ? [] : data.products␊
    		.map(product =&gt; {␊
    			// 没有商品或者原价的是非法数据␊
    			if (!product.items || typeof product.price !== &#39;number&#39;) return null;␊
    ␊
    			const someItemIllegal = product.items.some(item =&gt;␊
    				!item.id ||␊
    				typeof item.price !== &#39;number&#39;);␊
    ␊
    			if (someItemIllegal) return null;␊
    ␊
    ␊
    			const safeItems = items.map(item =&gt; ({␊
    				...item,␊
    				/**␊
    				 * 如果价格原价信息不存在␊
    				 * 在渲染NaN时提示用户原价数据异常␊
    				 * 由于原价仅仅用于展示，对交易无影响␊
    				 * 因此不需要移除项目，␊
    				 * 同时NaN会造成项目总原价计算为NaN␊
    				 * 总原价同时也可以提醒用户数据异常␊
    				 * 总价格也仅仅是展示，对交易无影响␊
    				 */␊
    				price: item.price || NaN,␊
    			}))␊
    ␊
    			return {␊
    				...product,␊
    				items: safeItems,␊
    			};␊
    		})␊
    		// 过滤非法数据␊
    		.filter(product =&gt; product)␊
    }</code></pre><p>这是多么大的一坨shit！这种代码维护起来简直让人痛苦。来瞧瞧我们如何同<a href="https://github.com/Val-istar-Guo/sanitization">sanitization</a>改写：␊
    ␊
    </p><pre><code class="javascript">const sanizate = sa.keys({␊
    	minPrice: sa.number.required(),␊
    	products: sa.filter({␊
    		items: sa.min(1).each({␊
    			id: sa.number.required(),␊
    			name: sa.string,␊
    			price: sa.number,␊
    			number: sa.number.required(),␊
    		},␊
    		price: sa.number.required(),␊
    	}),␊
    })␊
    ␊
    const safeData = sanizate(data)</code></pre><p>有心人可能大概猜到这些api的含义了，我这里简单解释下␊
    ␊
    </p><ul><li class="ul">`sa.string`要求这个字段必须为`string`格式，如果不是string，则会尝试强制转换为string，如果为`null`、`undefined`或者字段不存在则会设置为空字符串。</li><li class="ul">`sa.number` 将字段转化为number类型，如果为可以数字组成的字符串，则转化成对应的数字；如果字段为ture/false，则转化为1/0；如果为其他值，则转化为NaN</li><li class="ul">`sa.number.required()`在结尾添加`.required()`则意味着这个字段必须为number，如果这个字段不是number类型，则会上报错误</li><li class="ul">`sa.filter` 这个api会要求对应字段为一个数组，并且，对数组的每一个进行验证，如果其中某一项上报了错误，则在数组中删除这一项。</li><li class="ul">`sa.each` 与`sa.filter`不一样的是，如果数组中的某一项上报错误，则认为整个数组的数据不正确，并将错误继续上报。它要求了凡是数组中存在的数据必须全部正确。</li><li class="ul">`sa.min(number)`这个api与`sa.each`一起用，意思是数组长度至少为`number`，如果小于这个数字，则会往数组中填充null。</li></ul><p>简单了解这些api之后你会发现，短短十几行代码，比上面几十行代码功能还要强大。同时更容易维护和理解。␊
    ␊
    </p><h3>展示给老板的编辑页面</h3><p>与展示给客户不同的地方在于，对于错误的价格和数量数据，我们需要让输入框处于未填写状态。␊
    ␊
    </p><p>假设我们的价格都是从<code>&lt;input type=&quot;text&quot; /&gt;</code>输入框中输入的。输入框参数和输出往往是字符串。␊
    为了方便操作，我们可以将数据转化成字符串，填充输入框。对于非法数据则填充空字符串，以供老板修正。␊
    ␊
    </p><pre><code class="javascript">const sanizate = sa.keys({␊
    	minPrice: sa.number.stringify,␊
    	products: sa.filter({␊
    		items: sa.min(1).each({␊
    			id: sa.number,␊
    			name: sa.string,␊
    			price: sa.number.stringify,␊
    			number: sa.number.stringify,␊
    		},␊
    		price: sa.number.stringify,␊
    	}),␊
    })␊
    ␊
    const safeData = sanizate(data)</code></pre><ul><li class="ul">`sa.number.stringify` 将字段转化为number后，再转化为字符串，此时NaN将被转化为空字符串，`.stringify`是`.string`的语法糖</li></ul><p>通过<code>sa.number.stringify</code>我们可以将非法数字转化为输入框内的合法值或空字符串（而不是渲染成NaN）。␊
    从而提醒老板重新录入数据并保存，解决可能存在的数据库存入脏数据的情况。␊
    ␊
    </p><h2>重复我的论点</h2><p>我认为，在拿到数据后，我们应当对数据进行<strong class="asterisk">结构校准<strong class="asterisk">、</strong>数据过滤</strong>，将可以直接渲染的数据交给组件模块去渲染，而不是在组件模块中增加一堆复杂的数据逻辑的判断。因为你永远不知道，未来是否有人维护你的代码时，会不会将你的数据传个其他组件去渲染，而并未带走你复杂的排错逻辑。</p>`

> Snapshot 3

    ''
